
/**
 * The phrase numbers can be efficiently represented
 * in fewest bits possible to represent a number less
 * than or equal to the number of phrases in the dictionary
 * at the time the number is generated by the encoder (i.e.
 * the range of valid phrase numbers).
 * 
 * Since most programming languages only allow I/O in bytes
 * it is tricky to combine any old number of bits into an output
 * stream of bytes (or byte-sizes types)
 * 
 * So the most efficient phrase encoder needs to pack the phrase
 * numbers into that stream of bytes through bit-wise operations
 * (i.e. shift, etc), and then these phrase numbers would have
 * to be unpacked prior to decoding the pharse numbers.
 * 
 * For your assignment, it is probably easier to pack from right-to-left,
 * and when you have a byte or two filled with useful data in the least
 * significant position, send them to your output (or output buffer) and
 * right shift the pattern in the working area (i.e. the 32-bit int, in
 * this case) so you have more room at the left end to place more bits.
 * That is, the data you are trying to preserve is often not a multiple
 * of 8-bits, but your output has to be, so you are placing the bits into
 * another data type (like an int) .... filling it from right to left and
 * dumping out your data whenever you have a complete byte (or two) because
 * that's the minimum unit of output.
 * The trick is ... what to do when the data runs out and you still have a few
 * bits left over in your int ?!
 */

import java.io.*;

class LZWpack {

    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream(new File("output.txt"));
            BufferedReader br = new BufferedReader(new InputStreamReader(fis));

            String line = br.readLine();

            while(line != null) {
                int phraseNumber = Integer.parseInt(line);      
            }

        } catch(Exception e) {
            System.err.println(e);
        }
    }
}